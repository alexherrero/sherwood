name: Test Coverage

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "**" ]

jobs:
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: '1.25.7'

      - name: Install dependencies
        run: go mod download

      - name: Run Tests with Coverage
        run: |
          echo "mode: atomic" > coverage.out
          # Get all packages except ignored ones (if any)
          PACKAGES=$(go list ./...)
          
          # Run tests for each package
          for pkg in $PACKAGES; do
            go test -v -coverpkg=./... -covermode=atomic -coverprofile=profile.out $pkg
            if [ -f profile.out ]; then
              tail -n +2 profile.out >> coverage.out
              rm profile.out
            fi
          done

      - name: Calculate Coverage
        run: |
          go tool cover -func=coverage.out
          
          # Extract total coverage percentage
          TOTAL_COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}')
          
          echo "Total Coverage: $TOTAL_COVERAGE%"
          
          # Check if coverage is below 80%
          if awk "BEGIN {exit !($TOTAL_COVERAGE < 80)}"; then
            echo "::error::Coverage is below 80% ($TOTAL_COVERAGE%)"
            exit 1
          else
            echo "Coverage check passed ($TOTAL_COVERAGE%)"
          fi

      - name: Generate Coverage Summary
        if: always()
        shell: python
        env:
          THRESHOLD: 80
        run: |
          import os
          import sys
          import subprocess

          coverage_file = "coverage.out"
          if not os.path.exists(coverage_file):
              print("No coverage file found")
              sys.exit(0)

          # Use go tool cover to get official metrics
          try:
              result = subprocess.run(
                  ["go", "tool", "cover", "-func=coverage.out"],
                  capture_output=True,
                  text=True,
                  check=True
              )
              output_lines = result.stdout.strip().splitlines()
          except subprocess.CalledProcessError as e:
              print(f"Error running go tool cover: {e}")
              sys.exit(0)

          if not output_lines:
              print("No coverage data")
              sys.exit(0)

          total_line = output_lines[-1]
          # Total line format: "total: (statements) 85.5%"
          total_coverage_pct = 0.0
          if "total:" in total_line:
              try:
                  pct_str = total_line.split()[-1].replace("%", "")
                  total_coverage_pct = float(pct_str)
              except ValueError:
                  pass

          # Parse individual file stats from output
          # Line format: "github.com/alexherrero/sherwood/backend/file.go:10: FuncName 100.0%"
          file_percentages = []
          highest_cov = -1.0
          highest_file = "N/A"
          lowest_cov = 101.0
          lowest_file = "N/A"

          for line in output_lines[:-1]: # Skip total line
              parts = line.split()
              if len(parts) < 3: continue
              
              # Last part is percentage
              try:
                  pct = float(parts[-1].replace("%", ""))
                  file_path = parts[0]
                  # Clean up path to show relative path
                  if "github.com/alexherrero/sherwood/" in file_path:
                      file_path = file_path.split("github.com/alexherrero/sherwood/")[-1]
                  # remove function name details usually usually attached or clean up
                  # output format is actually: package/file.go:line: function	pct%
                  # let's just take the file path part before the colon
                  filename = file_path.split(":")[0]
                  
                  file_percentages.append((filename, pct))
              except ValueError:
                  continue
          
          # Aggregate by file since go tool cover outputs by function
          file_map = {}
          for fname, pct in file_percentages:
              if fname not in file_map:
                  file_map[fname] = []
              file_map[fname].append(pct)
          
          # Calculate per-file averages
          final_file_stats = []
          for fname, pcts in file_map.items():
              avg = sum(pcts) / len(pcts)
              final_file_stats.append((fname, avg))
              
              if avg > highest_cov:
                  highest_cov = avg
                  highest_file = fname
              if avg < lowest_cov:
                  lowest_cov = avg
                  lowest_file = fname

          avg_file_coverage = sum(stat[1] for stat in final_file_stats) / len(final_file_stats) if final_file_stats else 0.0

          pass_threshold = float(os.environ.get("THRESHOLD", 80))
          passed = total_coverage_pct >= pass_threshold
          
          status_header = "✅ PASS" if passed else "❌ FAIL"

          summary_md = f"""
          # Code Coverage Summary: {status_header}

          | Metric | Value | File (if applicable) |
          | :--- | :--- | :--- |
          | **Total Coverage** | **{total_coverage_pct:.1f}%** | All Files |
          | **Threshold** | {pass_threshold}% | Required |
          | **Average File Coverage** | {avg_file_coverage:.1f}% | (Across {len(final_file_stats)} files) |
          | **Highest File Coverage** | {highest_cov:.1f}% | `{highest_file}` |
          | **Lowest File Coverage** | {lowest_cov:.1f}% | `{lowest_file}` |
          """
          
          step_summary_file = os.environ.get("GITHUB_STEP_SUMMARY")
          if step_summary_file:
              with open(step_summary_file, "a") as f:
                  f.write(summary_md)
