name: "[T] Test Pipeline"

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - "**"
  workflow_dispatch:

concurrency:
  group: test-pipeline-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # â”€â”€ Stage 1: Unit Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  unit-tests:
    name: Unit Tests (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    timeout-minutes: 15
    permissions:
      contents: read
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Setup Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version: "1.25.7"

      - name: Install Dependencies
        run: go mod download

      - name: Run Tests
        shell: bash
        run: |
          set +e
          go test -v ./... > test_output.txt 2>&1
          TEST_EXIT_CODE=$?
          set -e

          cat test_output.txt

          TOTAL=$(grep -c -E "^\s*=== RUN" test_output.txt || true)
          PASS=$(grep -c -E "^\s*--- PASS:" test_output.txt || true)
          FAIL=$(grep -c -E "^\s*--- FAIL:" test_output.txt || true)
          SKIP=$(grep -c -E "^\s*--- SKIP:" test_output.txt || true)

          echo "## ðŸ§ª Unit Tests (${{ matrix.os }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$FAIL" -gt 0 ]; then
            echo "### âŒ $FAIL / $TOTAL tests failed" >> $GITHUB_STEP_SUMMARY
          elif [ "$SKIP" -gt 0 ]; then
            echo "### âœ… $PASS passed, â­ï¸ $SKIP skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âœ… All $TOTAL tests passed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Total | $TOTAL |" >> $GITHUB_STEP_SUMMARY
          echo "| âœ… Passed | $PASS |" >> $GITHUB_STEP_SUMMARY
          echo "| âŒ Failed | $FAIL |" >> $GITHUB_STEP_SUMMARY
          echo "| â­ï¸ Skipped | $SKIP |" >> $GITHUB_STEP_SUMMARY

          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### âŒ Failures" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            grep -E "^--- FAIL:|FAIL|panic:|[a-zA-Z0-9_]+\.go:[0-9]+:" test_output.txt | grep -v "PASS:" || true >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            exit $TEST_EXIT_CODE
          fi

      - name: Build
        run: go build -v ./backend/...

  # â”€â”€ Stage 2: Integration Tests (after unit tests pass) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  integration-tests:
    name: Integration Tests
    needs: unit-tests
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Setup Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version: "1.25.7"

      - name: Install Dependencies
        run: go mod download

      - name: Build Backend
        run: go build -o sherwood ./backend/main.go

      - name: Run Order Persistence Tests
        shell: bash
        env:
          CI_API_KEY: ${{ secrets.CI_API_KEY }}
        run: |
          set -o pipefail
          {
            TEST_KEY="$CI_API_KEY"

            # Create test config
            cat > .env << EOF
          PORT=8099
          HOST=127.0.0.1
          API_KEY=$TEST_KEY
          TRADING_MODE=dry_run
          DATABASE_PATH=./data/test_persistence.db
          LOG_LEVEL=info
          DATA_PROVIDER=yahoo
          ALLOWED_ORIGINS=http://localhost:3000,http://localhost:8099
          ENABLED_STRATEGIES=ma_crossover
          EOF

            # Start server (first run)
            ./sherwood &
            SERVER_PID=$!
            echo $SERVER_PID > server.pid
            echo "Server started with PID: $SERVER_PID"
            sleep 5

            # Verify server is running
            echo "Verifying Health Endpoint..."
            curl --retry 5 --retry-delay 2 --retry-connrefused http://127.0.0.1:8099/health
            echo "âœ… Health check passed"

            # Submit test order
            echo "Submitting Order..."
            RESPONSE=$(curl -s -X POST http://127.0.0.1:8099/api/v1/execution/orders \
              -H "Content-Type: application/json" \
              -H "X-Sherwood-API-Key: $TEST_KEY" \
              -d '{"symbol":"BTC-USD","side":"buy","type":"limit","quantity":0.01,"price":50000.00}')
            echo "Order response: $RESPONSE"
            ORDER_ID=$(echo $RESPONSE | jq -r '.id')

            if [ -z "$ORDER_ID" ] || [ "$ORDER_ID" = "null" ]; then
              echo "âœ— Failed to submit order"
              kill $SERVER_PID
              exit 1
            fi
            echo "âœ… Submitted order: $ORDER_ID"

            # Stop server
            echo "Stopping server..."
            kill $SERVER_PID || true
            sleep 2

            # Verify database file exists
            if [ ! -f ./data/test_persistence.db ]; then
              echo "âœ— Database file not found!"
              exit 1
            fi
            echo "âœ… Database file exists"

            # Restart server (second run)
            echo "Restarting server..."
            ./sherwood &
            SERVER_PID=$!
            echo $SERVER_PID > server2.pid
            sleep 5

            # Verify server restarted
            curl --retry 5 --retry-delay 2 --retry-connrefused http://127.0.0.1:8099/health
            echo "âœ… Health check passed after restart"

            # Verify order persisted
            echo "Checking for order: $ORDER_ID"
            RESPONSE=$(curl -s http://127.0.0.1:8099/api/v1/execution/orders \
              -H "X-Sherwood-API-Key: $TEST_KEY")

            RETRIEVED_ID=$(echo $RESPONSE | jq -r ".orders[] | select(.id==\"$ORDER_ID\") | .id")
            if [ "$RETRIEVED_ID" != "$ORDER_ID" ]; then
              echo "âœ— Order not found after restart! Expected: $ORDER_ID"
              kill $SERVER_PID
              exit 1
            fi
            echo "âœ… Order successfully persisted across restart!"

            # Verify trade history
            RESPONSE=$(curl -s http://127.0.0.1:8099/api/v1/execution/trades \
              -H "X-Sherwood-API-Key: $TEST_KEY")
            if echo "$RESPONSE" | grep -q "error"; then
              echo "âœ— Failed to fetch trades"
              kill $SERVER_PID
              exit 1
            fi
            echo "âœ… Trade history endpoint functional"

            # Verify order modification
            RESPONSE=$(curl -s -X POST http://127.0.0.1:8099/api/v1/execution/orders \
              -H "Content-Type: application/json" \
              -H "X-Sherwood-API-Key: $TEST_KEY" \
              -d '{"symbol":"ETH-USD","side":"buy","type":"limit","quantity":1.0,"price":3000.00}')
            MOD_ORDER_ID=$(echo $RESPONSE | jq -r '.id')
            MOD_RESPONSE=$(curl -s -X PATCH http://127.0.0.1:8099/api/v1/execution/orders/$MOD_ORDER_ID \
              -H "Content-Type: application/json" \
              -H "X-Sherwood-API-Key: $TEST_KEY" \
              -d '{"price": 3100.00}')
            NEW_PRICE=$(echo $MOD_RESPONSE | jq -r '.price')
            if [ "$NEW_PRICE" != "3100" ]; then
              echo "âœ— Order modification failed!"
              kill $SERVER_PID
              exit 1
            fi
            echo "âœ… Order modification verified"

            # Cleanup
            kill $SERVER_PID || true
            rm -f ./data/test_persistence.db
          } 2>&1 | tee persistence_output.txt

      - name: Run API & Config Tests
        shell: bash
        env:
          CI_API_KEY: ${{ secrets.CI_API_KEY }}
        run: |
          set -o pipefail
          {
            TEST_KEY="$CI_API_KEY"

            # Start with API key
            API_KEY="$TEST_KEY" ./sherwood &
            SERVER_PID=$!
            sleep 5

            # Verify Historical Data (Simulate Failure/Ignored)
            echo "Verifying History Endpoint..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "X-Sherwood-API-Key: $TEST_KEY" "http://localhost:8099/api/v1/data/history?symbol=SPY&interval=1d")
            if [ "$HTTP_CODE" != "200" ]; then
                 echo "History check failed with status $HTTP_CODE (ignoring for now, likely network issue)"
            else
                 echo "âœ… History check passed"
            fi

            # Verify Security Headers
            HEADERS=$(curl -s -I http://localhost:8099/health)
            if echo "$HEADERS" | grep -q "X-Frame-Options: DENY"; then
                 echo "âœ… X-Frame-Options header present"
            else
                 echo "âœ— Security headers missing"
                 kill $SERVER_PID
                 exit 1
            fi

            # Verify Dynamic Config (Enable Multiple Strategies)
            echo "Testing Multi-Strategy Config..."
            kill $SERVER_PID || true
            sleep 2

            ENABLED_STRATEGIES="ma_crossover,rsi_momentum" API_KEY="$TEST_KEY" ./sherwood &
            TEST_PID=$!
            sleep 5

            RESPONSE=$(curl -s -H "X-Sherwood-API-Key: $TEST_KEY" http://localhost:8099/api/v1/strategies)
            if echo "$RESPONSE" | grep -q "ma_crossover" && echo "$RESPONSE" | grep -q "rsi_momentum"; then
              echo "âœ… Multiple strategies verified"
            else
              echo "âœ— Multiple strategies failed"
              kill $TEST_PID
              exit 1
            fi

            kill $TEST_PID || true
          } 2>&1 | tee api_config_output.txt

      - name: Generate Integration Summary
        if: always()
        shell: bash
        run: |
          echo "## ðŸ§ª Integration Tests" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          process_log() {
            local file=$1
            local name=$2

            if [ -f "$file" ]; then
              PASS_COUNT=$(grep -E -i "âœ“|âœ…|passed|functional" "$file" | wc -l || true)

              # Failures that match 'ignoring' are counted as Ignored, not Failed
              FAIL_COUNT=$(grep -E -i "âœ—|failed" "$file" | grep -v -i "ignoring" | wc -l || true)
              IGNORED_COUNT=$(grep -E -i "failed" "$file" | grep -i "ignoring" | wc -l || true)

              TOTAL=$((PASS_COUNT + FAIL_COUNT + IGNORED_COUNT))

              echo "### $name" >> $GITHUB_STEP_SUMMARY
              echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
              echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
              echo "| Total | $TOTAL |" >> $GITHUB_STEP_SUMMARY
              echo "| âœ… Passed | $PASS_COUNT |" >> $GITHUB_STEP_SUMMARY
              echo "| âŒ Failed | $FAIL_COUNT |" >> $GITHUB_STEP_SUMMARY
              echo "| âš ï¸ Ignored | $IGNORED_COUNT |" >> $GITHUB_STEP_SUMMARY

              if [ $FAIL_COUNT -gt 0 ]; then
                 echo "" >> $GITHUB_STEP_SUMMARY
                 echo "#### âŒ Failures" >> $GITHUB_STEP_SUMMARY
                 echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                 grep -E -i "âœ—|failed" "$file" | grep -v -i "ignoring" >> $GITHUB_STEP_SUMMARY || true
                 echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              fi

              if [ $IGNORED_COUNT -gt 0 ]; then
                 echo "" >> $GITHUB_STEP_SUMMARY
                 echo "#### âš ï¸ Ignored Issues" >> $GITHUB_STEP_SUMMARY
                 echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
                 grep -E -i "failed" "$file" | grep -i "ignoring" >> $GITHUB_STEP_SUMMARY || true
                 echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "### $name" >> $GITHUB_STEP_SUMMARY
              echo "No output log found." >> $GITHUB_STEP_SUMMARY
            fi
          }

          process_log "persistence_output.txt" "Order Persistence Tests"
          process_log "api_config_output.txt" "API & Configuration Tests"

  # â”€â”€ Stage 3: Coverage (after integration tests pass) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  coverage:
    name: Code Coverage
    needs: integration-tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Setup Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version: "1.25.7"

      - name: Install Dependencies
        run: go mod download

      - name: Run Tests with Coverage
        run: |
          echo "mode: atomic" > coverage.out
          PACKAGES=$(go list ./...)

          for pkg in $PACKAGES; do
            go test -v -coverpkg=./... -covermode=atomic -coverprofile=profile.out $pkg
            if [ -f profile.out ]; then
              tail -n +2 profile.out >> coverage.out
              rm profile.out
            fi
          done

      - name: Calculate Coverage
        run: |
          go tool cover -func=coverage.out

          TOTAL_COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}')

          echo "Total Coverage: $TOTAL_COVERAGE%"

          if awk "BEGIN {exit !($TOTAL_COVERAGE < 80)}"; then
            echo "::error::Coverage is below 80% ($TOTAL_COVERAGE%)"
            exit 1
          else
            echo "Coverage check passed ($TOTAL_COVERAGE%)"
          fi

      - name: Generate Coverage Summary
        if: always()
        shell: python
        env:
          THRESHOLD: 80
        run: |
          import os
          import sys
          import subprocess

          coverage_file = "coverage.out"
          if not os.path.exists(coverage_file):
              print("No coverage file found")
              sys.exit(0)

          try:
              result = subprocess.run(
                  ["go", "tool", "cover", "-func=coverage.out"],
                  capture_output=True,
                  text=True,
                  check=True
              )
              output_lines = result.stdout.strip().splitlines()
          except subprocess.CalledProcessError as e:
              print(f"Error running go tool cover: {e}")
              sys.exit(0)

          if not output_lines:
              print("No coverage data")
              sys.exit(0)

          total_line = output_lines[-1]
          total_coverage_pct = 0.0
          if "total:" in total_line:
              try:
                  pct_str = total_line.split()[-1].replace("%", "")
                  total_coverage_pct = float(pct_str)
              except ValueError:
                  pass

          file_percentages = []
          highest_cov = -1.0
          highest_file = "N/A"
          lowest_cov = 101.0
          lowest_file = "N/A"

          for line in output_lines[:-1]:
              parts = line.split()
              if len(parts) < 3: continue

              try:
                  pct = float(parts[-1].replace("%", ""))
                  file_path = parts[0]
                  if "github.com/alexherrero/sherwood/" in file_path:
                      file_path = file_path.split("github.com/alexherrero/sherwood/")[-1]
                  filename = file_path.split(":")[0]

                  file_percentages.append((filename, pct))
              except ValueError:
                  continue

          file_map = {}
          for fname, pct in file_percentages:
              if fname not in file_map:
                  file_map[fname] = []
              file_map[fname].append(pct)

          final_file_stats = []
          for fname, pcts in file_map.items():
              avg = sum(pcts) / len(pcts)
              final_file_stats.append((fname, avg))

              if avg > highest_cov:
                  highest_cov = avg
                  highest_file = fname
              if avg < lowest_cov:
                  lowest_cov = avg
                  lowest_file = fname

          avg_file_coverage = sum(stat[1] for stat in final_file_stats) / len(final_file_stats) if final_file_stats else 0.0

          pass_threshold = float(os.environ.get("THRESHOLD", 80))
          passed = total_coverage_pct >= pass_threshold

          status_header = "âœ… PASS" if passed else "âŒ FAIL"

          summary_md = f"""## ðŸ“Š Code Coverage: {status_header}

          | Metric | Value | File (if applicable) |
          | :--- | :--- | :--- |
          | **Total Coverage** | **{total_coverage_pct:.1f}%** | All Files |
          | **Threshold** | {pass_threshold}% | Required |
          | **Average File Coverage** | {avg_file_coverage:.1f}% | (Across {len(final_file_stats)} files) |
          | **Highest File Coverage** | {highest_cov:.1f}% | `{highest_file}` |
          | **Lowest File Coverage** | {lowest_cov:.1f}% | `{lowest_file}` |
          """

          step_summary_file = os.environ.get("GITHUB_STEP_SUMMARY")
          if step_summary_file:
              with open(step_summary_file, "a") as f:
                  f.write(summary_md)

  # â”€â”€ Stage 4: Codebase Stats (after all tests pass) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  codebase-stats:
    name: Codebase Stats
    needs: [unit-tests, integration-tests, coverage]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Generate Codebase Stats Summary
        run: |
          echo "## ðŸ“ Codebase Stats" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # â”€â”€ Count source lines per language â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          GO_SRC=$(find . -name '*.go' -type f \
            -not -path '*/vendor/*' -not -path '*/.git/*' \
            -not -path '*/node_modules/*' \
            -not -name '*_test.go' \
            | xargs cat 2>/dev/null | wc -l)

          GO_TEST=$(find . -name '*_test.go' -type f \
            -not -path '*/vendor/*' -not -path '*/.git/*' \
            -not -path '*/node_modules/*' \
            | xargs cat 2>/dev/null | wc -l)

          TS_SRC=$(find . -name '*.ts' -o -name '*.tsx' | grep -v node_modules | grep -v '.git' | grep -v -E '\.test\.|\.spec\.' \
            | xargs cat 2>/dev/null | wc -l)

          TS_TEST=$(find . \( -name '*.test.ts' -o -name '*.test.tsx' -o -name '*.spec.ts' -o -name '*.spec.tsx' \) -type f \
            -not -path '*/node_modules/*' -not -path '*/.git/*' \
            | xargs cat 2>/dev/null | wc -l)

          YAML_SRC=$(find . \( -name '*.yml' -o -name '*.yaml' \) -type f \
            -not -path '*/node_modules/*' -not -path '*/.git/*' \
            | xargs cat 2>/dev/null | wc -l)

          SQL_SRC=$(find . -name '*.sql' -type f \
            -not -path '*/node_modules/*' -not -path '*/.git/*' \
            | xargs cat 2>/dev/null | wc -l)

          CSS_SRC=$(find . -name '*.css' -type f \
            -not -path '*/node_modules/*' -not -path '*/.git/*' \
            | xargs cat 2>/dev/null | wc -l)

          # â”€â”€ Calculate totals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          TOTAL_SRC=$((GO_SRC + TS_SRC + YAML_SRC + SQL_SRC + CSS_SRC))
          TOTAL_TEST=$((GO_TEST + TS_TEST))
          TOTAL_ALL=$((TOTAL_SRC + TOTAL_TEST))

          # â”€â”€ Calculate percentages (avoid division by zero) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          calc_pct() {
            local part=$1 whole=$2
            if [ "$whole" -gt 0 ]; then
              echo "scale=1; $part * 100 / $whole" | bc
            else
              echo "0"
            fi
          }

          calc_ratio() {
            local test=$1 src=$2
            if [ "$src" -gt 0 ]; then
              echo "scale=1; $test * 100 / $src" | bc
            else
              echo "â€”"
            fi
          }

          GO_PCT=$(calc_pct $GO_SRC $TOTAL_SRC)
          TS_PCT=$(calc_pct $TS_SRC $TOTAL_SRC)
          YAML_PCT=$(calc_pct $YAML_SRC $TOTAL_SRC)
          SQL_PCT=$(calc_pct $SQL_SRC $TOTAL_SRC)
          CSS_PCT=$(calc_pct $CSS_SRC $TOTAL_SRC)

          GO_RATIO=$(calc_ratio $GO_TEST $GO_SRC)
          TS_RATIO=$(calc_ratio $TS_TEST $TS_SRC)

          # â”€â”€ Format numbers with comma separators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          fmt() { printf "%'d" "$1"; }

          # â”€â”€ Write summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          echo "### ðŸ“Š Lines of Code" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Total: $(fmt $TOTAL_ALL) lines** ($(fmt $TOTAL_SRC) source + $(fmt $TOTAL_TEST) test)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Language | Source LOC | % of Source | Test LOC | Test Ratio |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-----------|-------------|----------|------------|" >> $GITHUB_STEP_SUMMARY
          echo "| Go (\`.go\`) | $(fmt $GO_SRC) | ${GO_PCT}% | $(fmt $GO_TEST) | ${GO_RATIO}% |" >> $GITHUB_STEP_SUMMARY
          echo "| TypeScript (\`.ts/.tsx\`) | $(fmt $TS_SRC) | ${TS_PCT}% | $(fmt $TS_TEST) | ${TS_RATIO}% |" >> $GITHUB_STEP_SUMMARY
          echo "| CSS (\`.css\`) | $(fmt $CSS_SRC) | ${CSS_PCT}% | â€” | â€” |" >> $GITHUB_STEP_SUMMARY
          echo "| SQL (\`.sql\`) | $(fmt $SQL_SRC) | ${SQL_PCT}% | â€” | â€” |" >> $GITHUB_STEP_SUMMARY
          echo "| YAML (\`.yml\`) | $(fmt $YAML_SRC) | ${YAML_PCT}% | â€” | â€” |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Test Ratio** = test lines Ã· source lines Ã— 100. Higher is better â€” indicates more thorough testing relative to code volume." >> $GITHUB_STEP_SUMMARY
